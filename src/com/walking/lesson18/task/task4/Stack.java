package com.walking.lesson18.task.task4;

import java.util.EmptyStackException;

/*
 * Реализовать параметризованный класс, хранящий и обрабатывающий стек. Стек — структура данных, в котором каждый элемент хранит ссылку на следующий. Работает по принципу LIFO (последний вошел — первый вышел).

Реализовать следующие методы:

    Добавление элемента в стек;
    Удаление элемента из стека. При удалении несуществующего элемента – исключение;
    Получение глубины (количества элементов) стека;
    Поиск по стеку, при отсутствии искомого значения – исключение;
    Получение строкового эквивалента элементов стека, представленных в виде массива ([строковое представление элемента1, ..., строковое представление элементаN]).
 */

public class Stack<T> {
    private Node<T> top; // Вершина стека
    private int size; // Размер стека

    // Вложенный класс для представления узла стека
    private static class Node<T> {
        private T data; // Данные узла
        private Node<T> next; // Ссылка на следующий узел

        // Конструктор узла
        public Node(T data) {
            this.data = data;
        }
    }

    // Добавление элемента в стек
    public void push(T item) {
        Node<T> newNode = new Node<>(item); // Создаем новый узел
        newNode.next = top; // Устанавливаем следующий узел для нового узла на текущую вершину стека
        top = newNode; // Перемещаем вершину стека на новый узел
        size++; // Увеличиваем размер стека
    }

    // Удаление элемента из стека
    public T pop() {
        if (isEmpty()) { // Проверяем, пуст ли стек
            throw new EmptyStackException(); // Если стек пуст, выбрасываем исключение
        }
        T data = top.data; // Получаем данные из вершины стека
        top = top.next; // Перемещаем вершину стека на следующий узел
        size--; // Уменьшаем размер стека
        return data; // Возвращаем удаленные данные
    }

    // Получение глубины стека
    public int size() {
        return size; // Возвращаем размер стека
    }

    public boolean contains(T item) {
        Node<T> current = top; // Начинаем поиск с вершины стека
        while (current != null) { // Пока не достигнут конец стека
            if (current.data.equals(item)) { // Если текущий узел содержит искомый элемент
                return true; // Возвращаем true
            }
            current = current.next; // Переходим к следующему узлу
        }
        return false; // Если искомый элемент не найден, возвращаем false
    }

    // Получение строкового представления элементов стека в виде массива
    public String toStringArray() {
        StringBuilder builder = new StringBuilder("["); // Создаем строковый билдер для формирования строки
        Node<T> current = top; // Начинаем с вершины стека
        while (current != null) { // Пока не достигнут конец стека
            builder.append(current.data.toString()); // Добавляем данные текущего узла в строку
            if (current.next != null) { // Если узел не последний
                builder.append(", "); // Добавляем разделитель
            }
            current = current.next; // Переходим к следующему узлу
        }
        builder.append("]"); // Завершаем строку
        return builder.toString(); // Возвращаем строковое представление массива
    }

    // Проверка на пустоту
    public boolean isEmpty() {
        return top == null; // Возвращаем true, если вершина стека равна null (стек пуст)
    }

    // Очистка стека
    public void clear() {
        top = null; // Устанавливаем вершину стека в null
        size = 0; // Обнуляем размер стека
    }
}